{
  "name": "reflux",
  "version": "0.1.7",
  "homepage": "https://github.com/spoike/reflux",
  "authors": [
    "Mikael Brassman <mishakun@gmail.com>"
  ],
  "description": "A simple library for uni-directional dataflow architecture inspired by ReactJS Flux",
  "main": "dist/reflux.js",
  "keywords": [
    "action",
    "event",
    "data",
    "flux",
    "reactjs"
  ],
  "license": "BSD-3-Clause",
  "ignore": [
    "**/.*",
    "node_modules",
    "bower_components",
    "test",
    "src",
    "Gruntfile.js",
    "package.json",
    "README.md"
  ],
  "dependencies": {},
  "gitHead": "b35e4e8b35636e1e5f7024aacf3e6c41e8b976f5",
  "readme": "# Reflux\n\nA simple library for uni-directional dataflow architecture inspired by ReactJS [Flux](http://facebook.github.io/react/blog/2014/05/06/flux.html).\n\n[![Build Status](https://travis-ci.org/spoike/refluxjs.svg?branch=master)](https://travis-ci.org/spoike/refluxjs)\n\n[![Browser support](https://ci.testling.com/spoike/refluxjs.png)](https://ci.testling.com/spoike/refluxjs)\n\nYou can read an overview of Flux [here](http://facebook.github.io/react/docs/flux-overview.html), however the gist of it is to introduce a more functional programming style architecture by eschewing MVC like pattern and adopting a single data flow pattern.\n\n```\n╔═════════╗       ╔════════╗       ╔═════════════════╗\n║ Actions ║──────>║ Stores ║──────>║ View Components ║\n╚═════════╝       ╚════════╝       ╚═════════════════╝\n     ^                                      │\n     └──────────────────────────────────────┘\n\n```\n\nThe pattern is composed of actions and data stores, where actions initiate new data to pass through data stores before coming back to the view components again. If a view component has an event that needs to make a change in the application's data stores, they need to do so by signalling to the stores through the actions available.\n\nThe goal of the project is to get this architecture easily up and running in your web application, both client-side or server-side. There are some differences between how this project works and how Facebook's proposed Flux architecture works:\n\n* Instead of a singleton dispatcher, every action handles the dispatching by themselves\n* Javascript is a dynamic language so no more static type checking with strings! Just let the stores listen to actions and don't worry!\n\nYou can read more in this [blog post about React Flux vs Reflux](http://spoike.ghost.io/deconstructing-reactjss-flux/).\n\n## Installation\n\nYou can currently install the package as a npm package or bower.\n\n### NPM\n\nThe following command installs reflux as an npm package:\n\n    npm install reflux\n\n### Bower\n\nThe following command installs reflux as a bower component that can be used in the browser:\n\n    bower install reflux\n\n## Usage\n\nFor a full example check the [`test/index.js`](test/index.js) file.\n\n### Creating actions\n\nCreate an action by calling `Reflux.createAction`.\n\n```javascript\nvar statusUpdate = Reflux.createAction();\n```\n\nAn action is a functor that can be invoked like any function.\n\n```javascript\nstatusUpdate(); // Invokes the action statusUpdate\n```\n\nIt is as simple as that. There is also a convenience function for creating multiple actions.\n\n```javascript\nvar Actions = Reflux.createActions([\n    \"statusUpdate\",\n    \"statusEdited\",\n    \"statusAdded\"\n  ]);\n\n// Actions object now contains the actions\n// with the names given in the array above\n// that may be invoked as usual\n\nActions.statusUpdate();\n```\n\n#### Action hooks\n\nThere are a couple of hooks avaiable for each action.\n\n* `preEmit` - Is called before the action emits an event. It receives the arguments from the action invocation.\n\n* `shouldEmit` - Is called after `preEmit` and before the action emits an event. By default it returns `true` which will let the action emit the event. You may override this if you need to check the arguments that the action receives and see if it needs to emit the event.\n\nExample usage:\n\n```javascript\nActions.statusUpdate.preEmit = function() { console.log(arguments); };\nActions.statusUpdate.shouldEmit = function(value) {\n    return value > 0;\n};\n\nActions.statusUpdate(0);\nActions.statusUpdate(1);\n// Should output: 1\n```\n\n### Creating data stores\n\nCreate a data store much like ReactJS's own `React.createClass` by passing a definition object to `Reflux.createStore`. You may set up all action listeners in the `init` function and register them by calling the store's own `listenTo` function.\n\n```javascript\n// Creates a DataStore\nvar statusStore = Reflux.createStore({\n\n    // Initial setup\n    init: function() {\n\n        // Register statusUpdate action\n        this.listenTo(statusUpdate, this.output);\n    },\n\n    // Callback\n    output: function(flag) {\n        var status = flag ? 'ONLINE' : 'OFFLINE';\n\n        // Pass on to listeners\n        this.trigger(status);\n    }\n\n});\n```\n\nIn the above example, whenever the action is called, the store's `output` callback will be called with whatever parameters was sent in the action. E.g. if the action is called as `statusUpdate(true)` then the flag argument in `output` function is `true`.\n\n### Listening to changes in data store\n\nIn your component, register to listen to changes in your data store like this:\n\n```javascript\n// Fairly simple view component that outputs to console\nfunction ConsoleComponent() {\n\n    // Registers a console logging callback to the statusStore updates\n    statusStore.listen(function(status) {\n        console.log('status: ', status);\n    });\n};\n\nvar consoleComponent = new ConsoleComponent();\n```\n\nInvoke actions as if they were functions:\n\n```javascript\nstatusUpdate(true);\nstatusUpdate(false);\n```\n\nWith the setup above this will output the following in the console:\n\n```\nstatus:  ONLINE\nstatus:  OFFLINE\n```\n\n#### React component example\n\nRegister your component to listen for changes in your data stores, preferably in the `componentDidMount` [lifecycle method](http://facebook.github.io/react/docs/component-specs.html) and unregister in the `componentWillUnmount`, like this:\n\n```javascript\nvar Status = React.createClass({\n    initialize: function() { },\n    onStatusChange: function(status) {\n        this.setState({\n            currentStatus: status\n        });\n    },\n    componentDidMount: function() {\n        this.unsubscribe = statusStore.listen(this.onStatusChange);\n    },\n    componentWillUnmount: function() {\n        this.unsubscribe();\n    },\n    render: function() {\n        // render specifics\n    }\n});\n```\n\n#### Convenience mixin for React\n\nYou always need to unsubscribe components from observed actions and stores upon\nunmounting. To simplify this process you can use [mixins in React](http://facebook.github.io/react/docs/reusable-components.html#mixins). There is a convenience mixin available at `Reflux.ListenerMixin`.\n\n```javascript\nvar Status = React.createClass({\n    mixins: [Reflux.ListenerMixin],\n    onStatusChange: function(status) {\n        this.setState({\n            currentStatus: status\n        });\n    },\n    componentDidMount: function() {\n        this.listenTo(statusStore, this.onStatusChange);\n    },\n    render: function() {\n        // render specifics\n    }\n});\n```\n\nThe mixin provides the `listenTo` method for the React component, that works much like the one found in the Reflux's stores, and handles the listeners during mount and unmount for you.\n\n### Listening to changes in other data stores (aggregate data stores)\n\nA store may listen to another store's change, making it possible to safely chain stores for aggregated data without affecting other parts of the application. A store may listen to other stores using the same `listenTo` function as with actions:\n\n```javascript\n// Creates a DataStore that listens to statusStore\nvar statusHistoryStore = Reflux.createStore({\n    init: function() {\n\n        // Register statusStore's changes\n        this.listenTo(statusStore, this.output);\n\n        this.history = [];\n    },\n\n    // Callback\n    output: function(statusString) {\n        this.history.push({\n            date: new Date(),\n            status: statusString\n        });\n        // Pass the data on to listeners\n        this.trigger(this.history);\n    }\n\n});\n```\n## Advanced usage\n\n### Switching EventEmitter\n\nDon't like to use the EventEmitter provided? You can switch to another one, such as NodeJS's own like this:\n\n```javascript\n// Do this before creating actions or stores\n\nReflux.setEventEmitter(require('events').EventEmitter);\n```\n\n### Switching nextTick\n\nWhenever action functors are called, they return immediately through the use of `setTimeout` (`nextTick` function) internally.\n\nYou may switch out for your favorite `setTimeout`, `nextTick`, `setImmediate`, et al implementation:\n\n```javascript\n\n// node.js env\nReflux.nextTick(process.nextTick);\n```\n\nFor better alternative to `setTimeout`, you may opt to use the [`setImmediate` polyfill](https://github.com/YuzuJS/setImmediate).\n\n\n### Joining parallel listeners with composed listenables\n\nReflux makes it easy to listen to actions and stores that emit events in parallel. You can use this feature to compose and share listenable objects (composed listenables) among several stores.\n\n```javascript\nvar theTide = Reflux.all(waveAction, timeStore);\n\nvar clockStore = Reflux.createStore({\n    init: function() {\n        this.listenTo(theTide, this.theTideCallback);\n    },\n    theTideCallback: function(waveActionArgs, timeStoreArgs) {\n      // ...\n    }\n});\n\n// node.js environment\nif (process.env.DEVELOPMENT) {\n    theTide.listenTo(console.log.bind(console), window);\n}\n```\n\n`Reflux.all` always passes the last arguments that a listenable emitted to your callback, discarding subsequent emits. Arguments are passed in order. This means that the first argument which the callback receives, is the set of arguments which was emitted by the first listenable that was passed to `Reflux.all` and so on for the other arguments.\n\n#### Comparison with Flux's `waitFor()`\n\nThe `Reflux.all` functionality is similar to Flux's `waitFor()`, but differs in a few aspects:\n\n* Composed listenables may be reused by other stores\n* Composed listenables always emit asynchronously\n* Actions and stores may emit multiple times before the composed listenable (`theTide` in the example above) emits\n* Action and store callbacks are not executed in a single *synchronous* iteration\n\n### Sending default data with the listenTo function\n\nThe `listenTo` function provided by the `Store` and the `ListenerMixin` has a third parameter that accepts a callback. This callback will be invoked when the listener is registered with whatever the `getInitialData` is returning.\n\n```javascript\nvar exampleStore = Reflux.createStore({\n    init: function() {},\n    getInitialData: function() {\n        return \"the initial data\";\n    }\n});\n\n// Anything that will listen to the example store\nthis.listenTo(exampleStore, onChangeCallback, initialCallback)\n\n// initialCallback will be invoked immediately\n```\n\n## Colophon\n\n[List of contributors](https://github.com/spoike/reflux/graphs/contributors) is available on Github.\n\nThis project is licensed under [BSD 3-Clause License](http://opensource.org/licenses/BSD-3-Clause). Copyright (c) 2014, Mikael Brassman.\n\nFor more information about the license for this particular project [read the LICENSE.md file](LICENSE.md).\n\nThis project uses [eventemitter3](https://github.com/3rd-Eden/EventEmitter3), is currently MIT licensed and [has it's license information here](https://github.com/3rd-Eden/EventEmitter3/blob/master/LICENSE).\n",
  "readmeFilename": "README.md",
  "_id": "reflux@0.1.7",
  "repository": {
    "type": "git",
    "url": "git://github.com/spoike/reflux.git"
  }
}